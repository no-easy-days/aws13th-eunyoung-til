# HTTP
Hyper Text Transfer Protocol의 약자로, **웹에서 데이터를 주고받기 위한 어플리케이션 계층 프로토콜**

## 특징
### 무상태성(Stateless)
- 서버는 **각 요청을 독립적으로 처리**
- 클라이언트의 상태를 저장하지 않음

→ 쿠키나 세션으로 상태 관리

> [!NOTE]
> HTTP 자체는 stateless지만,  
> 쿠키·세션·JWT 같은 **상태 관리 메커니즘을 얹어** stateful하게 사용

---

### 확장성(Scalability)
- 서버가 클라이언트의 상태를 저장하지 않음
- 요청을 어떤 서버가 처리해도 상관없음

→ 로드 밸런싱 가능, 서버 증설이 쉬워짐

> [!IMPORTANT]
> HTTP는 연결이 불안정한 환경에서도
> 많은 클라이언트를 효율적으로 처리하기 위해
> 각 요청을 독립적으로 다루는 stateless 구조를 채택
> → 이는 확장성과 안정성의 핵심이 된다.

---

## HTTP 버전
| 버전                       | 배경                                                                                 | 주요 특징                                                                                                                                             | 한계                                                                   |
|--------------------------|------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------|
| HTTP/0.9 <br> (웹의 시작)    | 문서를 쉽게 공유하고 싶음                                                                     | - 최초 버전, 매우 단순한 구조 <br> - 단순 텍스트(HTML)만 전송 가능 <br> - GET 요청만 가능 <br> - 헤더 없음                                                                      | 이미지나 동영상 전송 불가                                                       |
| HTTP/1.0 <br> (멀티미디어 시대) | 미디어도 전송하고 싶음                                                                       | - 비연결성 <br> - 헤더 도입으로 파일 타입 알게 됨 <br> -  POST, HEAD 메서드 추가 <br> - 상태코드 도입 (1xx ~ 5xx)                                                             | 각 요청마다 새로운 연결 생성 <br> → 성능 저하                                       | 
| HTTP/1.1 <br> (연결 재사용)   | 웹 페이지 하나에 수십개의 파일 전송 필요해짐                                                          | - 지속 연결(keep-alive)로 성능 향상 <br> - 응답 기다리지 않고 연속 요청 (파이프라이닝) <br> - HOST 헤더 생성 <br> → 하나의 서버에서 여러 웹사이트 운영 가능                                      | HOL 블로킹 발생 → 너무 느림 (어플리케이션 레벨의 HOL 블로킹)                             |          
| HTTP/2 <br> (동시성 혁명)     | 현대의 웹페이지는 100개 이상의 리소스를 로드하는데 http/1.1은 너무 느림                                      | - 하나의 연결로 동시에 여러 요청/응답 (멀티플렉싱) <br> - 중복 헤더 압축 <br> → 데이터 양 감소 <br> - 요청 전에 미리 리소스 전송 (Server Push) <br> - 우선순위를 정해 중요한 정보 미리 전송 <br> → 체감 속도 향상 | 여전히 TCP 위에서 동작하기 때문에 네트워크에서 패킷 하나가 손실되면 모든 스트림이 멈춤 (TCP 레벨의 HOL 블로킹) |
| HTTP/3 <br> (UDP 기반 미래)  | 스마트폰 시대가 되면서 Wi-Fi ↔ 모바일 데이터 전환이 잦아짐 <br> → TCP는 이런 환경에서 연결과 연결 끊음을 반복 해야하는 문제 발생 | - UDP 기반 접근으로 TCP 기반의 HOL 블로킹 해결(QUIC 프로토콜) <br> -독립적 스트림 <br> → 패킷 손실된 스트림에만 영향 주어 전체적인 성능 안정                | 일부 기업망, 방화벽, 프록시에서 UDP 차단 <br> → 언제나 fallback 필요                    |

> [!NOTE]
> ## HOL 블로킹 (Head-Of-Line Blocking)**
> 앞선 요청이 지연되면 뒤따르는 요청들도 모두 지연되는 현상
> 
> ### **http/1.1**에서의 HOL 블로킹 (어플리케이션 계층)
> - 원인: 요청-응답 쌍이 항상 순서를 유지하고, 동기적으로 수행
> - 앞 요청이 느리면 뒤 요청들도 지연
> - 요청을 한 번에 여러개 보내도, 응답이 요청 순서대로 오기 때문에 병목 현상 발생
> 
> ### **http/2**에서의 HOL 블로킹 (전송 계층)
> - 원인: TCP 기반이기 때문에, 패킷 손실 시 재전송이 필요
> - 패킷 하나가 손실되면, 그 패킷 이후의 모든 패킷이 손실 패킷의 타임아웃 이후 재전송 될 때까지 대기
> - 결과적으로 모든 스트림이 멈추게 됨
> - http/1.1의 HOL 블로킹은 멀티플렉싱(동시 처리, 각 요청이 독립적으로 처리되어 지연 해결)으로 해결했지만 TCP기반 HOL 블로킹은 해결하지 못함
> - http/1.1은 두 종류의 HOL 블로킹이 모두 존재하는 셈

---

> [!NOTE]
> ## Server Push
> - 클라이언트가 요청하지 않은 리소스를 서버가 미리 전송하는 기능
> - 클라이언트가 필요로 할 리소스를 예측하여 미리 보내 성능 향상
> - 예: HTML 문서 요청 시, 관련된 CSS, JS 파일도 함께 전송
>   - 최초에는 client의 요청이 필수이며, 서버가 미리보내는 리소스가 필요 없는 경우 클라이언트가 거절 가능
> - 단점: 불필요한 리소스 전송으로 대역폭 낭비 가능성, 브라우저와 충돌
>   - 현재는 잘 사용되지 않음, 대신 CDN과 캐싱 전략 활용

---

> [!NOTE]
> ## TCP vs UDP
> ### **TCP (Transmission Control Protocol)**
> - 연결 지향적 프로토콜 (통신 전 3-way handshake 필요) → 오버헤드 큼
> - 느리지만 신뢰성 있는 데이터 전송 보장 (패킷 손실 시 재전송) → HOL 블로킹 발생 가능
> - 데이터 순서 보장
> - 흐름 제어 및 혼잡 제어 기능
> 
> ### **UDP (User Datagram Protocol)**
> - 비연결 지향적 프로토콜 (3-way handshake 없음, connectionless) → 오버헤드 적음
> - 빠르지만 신뢰성 낮음 (패킷 손실 시 재전송 없음) → HOL 블로킹 없음
> - 데이터 순서 보장 안됨
> - 흐름 제어 및 혼잡 제어 기능 없음

---

> [!NOTE]
> QUIC 프로토콜
> - Quick UDP Internet Connections의 약자입니다.
> - **Quick**: 빠른
> - **UDP**: 가벼운 전송 프로토콜
> - Google이 개발하여 현재 표준화됨
> TCP처럼 신뢰성을 보장하면서도 UDP의 **가벼움과 빠름**을 결합한 프로토콜

--- 
## HTTP Request
### 구조
```text
┌─────────────────────────────────────────────────┐
│ [1] 시작 라인 (Start Line)			  │
│     GET /users/jeff HTTP/1.1                    │
├─────────────────────────────────────────────────┤
│ [2] 헤더 (Headers)                               │
│     Host: api.example.com                       │
│     Content-Type: application/json              │
│     Authorization: Bearer token123              │
├─────────────────────────────────────────────────┤
│ [3] 빈 줄 (Empty Line)                           │
│                                                 │
├─────────────────────────────────────────────────┤
│ [4] 본문 (Body) - 선택사항			  │
│     { "name": "임태종", "role": "instructor" }	  │
└─────────────────────────────────────────────────┘
```

### 시작 라인
```javascript
GET /users/jeff HTTP/1.1
│    │           │
│    │           └─ HTTP 버전
│    └─ 요청 대상 경로 (URI)
└─ HTTP 메서드 (무엇을 할 것인가)
```

### Header
본문 보다 먼저 전달되는 정보

**Content-Type**
- `application/json` → JSON으로 파싱
- `text/html` → HTML로 렌더링
- `multipart/form-data` → 파일 업로드용

### 주요 Request Header

| Header | 설명 | 예시 |
|---|---|---|
| Host | 요청 대상 서버 주소 | `Host: www.notion.so` |
| Content-Type | 본문의 데이터 형식 | `Content-Type: application/json` |
| Content-Length | 본문의 길이 (바이트) | `Content-Length: 348` |
| Authorization | 인증 정보 | `Authorization: Bearer abc123` |
| User-Agent | 클라이언트 정보 | `User-Agent: Chrome/120.0` |
| Accept | 클라이언트가 받고 싶은 형식 | `Accept: text/html` |

## HTTP methods
클라이언트가 서버에 보내는 메세지

| Method | 주요 용도 | 멱등성 | 설명 |
|---|---|---|---|
| GET | 조회 | ✅ | 리소스를 조회만 함 |
| POST | 생성 | ❌ | 새 리소스 생성 또는 처리 요청 |
| PUT | 전체 수정 | ✅ | 리소스를 지정한 상태로 덮어씀 |
| PATCH | 부분 수정 | ❌ | 리소스의 일부만 변경 |
| DELETE | 삭제 | ✅ | 리소스를 삭제 |


> [!NOTE]
> **멱등성**
> - 여러번 반복해도 같은 결과를 가져오는 특성
> - GET, PUT, DELETE는 멱등성 있음
>   - GET: 여러번 호출해도 같은 리소스 반환
>   - PUT: 여러번 호출해도 같은 리소스 상태 유지
>   - DELETE: 여러번 호출해도 리소스 삭제 상태 유지


## HTTP Response
### 구조
```text
┌─────────────────────────────────────────────────┐
│ [1] 상태 라인 (Status Line)			  │
│     HTTP/1.1 200 OK                             │
├─────────────────────────────────────────────────┤
│ [2] 헤더 (Headers)                               │
│     Content-Type: application/json              │
│     Content-Length: 85                          │
├─────────────────────────────────────────────────┤
│ [3] 빈 줄 (Empty Line)                           │
│                                                 │
├─────────────────────────────────────────────────┤
│ [4] 본문 (Body)                                  │
│     { "id": 1, "name": "임태종", ... }		  │
└─────────────────────────────────────────────────┘
```

### 상태 라인
```text
HTTP/1.1 200 OK
│        │   │
│        │   └─ 상태 메시지 (사람이 읽기 쉬운 설명)
│        └─ 상태 코드 (기계가 이해하는 숫자)
└─ HTTP 버전
```
> [!NOTE]
> **401 vs 403 구분하기**
> - **401 Unauthorized**: "너 누구야?" → 인증(로그인)이 안 됨
> - **403 Forbidden**: "너인 건 알겠는데, 여긴 못 들어와" → 권한이 없음

### 주요 Response Header
| Header | 역할 | 예시 |
|---|---|---|
| Content-Type | 응답 데이터의 형식 | `Content-Type: text/html` |
| Content-Length | 응답 데이터의 크기 | `Content-Length: 1024` | 
| Set-Cookie | 브라우저에 저장할 쿠키 | `Set-Cookie: session=abc123` | 
| Cache-Control | 캐싱(저장) 정책 | `Cache-Control: max-age=3600` | 
| Location | 리다이렉트 주소 | `Location: /new-page` | 

### Body
- 실제 데이터가 담기는 부분
- Content-Type 헤더로 형식을 명시


## HTTP 캐싱
- 웹 리소스(이미지, HTML, CSS 등)를 브라우저나 중간 서버에 임시로 저장해두고, 동일 요청시 빠르게 불러오는 기술
→ 서버 부하 감소, 응답 속도 향상
- `Cache-Control`, `Expires`, `Last-Modified`, `ETag` 등의 HTTP 헤더를 사용하여 구현
→ 캐시의 유효 기간, 재검증 필요 여부 등 설정 가능

## CDN(Content Delivery Network)
- 전 세계에 분산된 서버 네트워크를 통해 웹 콘텐츠를 사용자에게 빠르게 제공하는 시스템
- 사용자와 지리적으로 가까운 서버에서 콘텐츠를 제공하여 지연 시간 감소
- 웹사이트의 글로벌 접근성 향상 및 피크 시간대의 트래픽 분산
- 리버스 프록시 서버로 동작
- 장점: 
  - 빠른 콘텐츠 전달
  - 서버 부하 감소
  - DDoS 공격 방어
    - 캐싱으로 원서버 접근 감소
    - 트래픽 분산
    - 트래픽 필터링
  - 가용성 및 안정성 향상
- 대표적인 CDN 서비스: Cloudflare, Akamai, Amazon CloudFront 등


<br><br>
reference: <br>
https://github.com/ej31